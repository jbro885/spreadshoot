{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["global","Buffer","App","props","state","name","playerId","roomId","enemies","dead","score","deaths","data","hotSettings","colHeaders","rowHeaders","rowHeights","selectionMode","licenseKey","hotTableComponent","React","createRef","client","Colyseus","sendMessage","keycode","console","log","joinOrCreate","then","room","id","sessionId","setState","length","send","entities","onAdd","entity","current","hotInstance","selectCell","y","x","setCellMeta","render","prevState","onChange","changes","setDataAtCell","newEnemies","Object","assign","i","catch","e","error","Handsontable","hooks","add","keyCode","stopImmediatePropagation","debugBox","this","className","src","alt","ref","settings","tabIndex","Component","Boolean","window","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.4468085b.chunk.js","sourcesContent":["import React from 'react';\n// import {render, findDOMNode} from 'react-dom';\nimport { HotTable } from '@handsontable/react';\nimport Handsontable from 'handsontable';\n\nimport { Buffer } from \"buffer\";\nimport * as Colyseus from \"colyseus.js\";\n\nimport './App.css';\n\nglobal.Buffer = Buffer;\nconst debug = true;\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: 'Roger',\n      playerId: 'en attente',\n      roomId: 'en attente',\n      enemies: [],\n      dead: false,\n      score: 0,\n      deaths: 0\n    };\n    \n    this.data = [\n      ['Planning vacances 2020', 'Dominique', 'Roger', 'Claude', 'Chantal'],\n      ['15 juin 2020', 0, 11, 12, 13],\n      ['16 juin 2020', 0, 11, 14, 13],\n      ['17 juin 2020', 0, 15, 12, 13],\n      ['18 juin 2020', 0, 15, 12, 13],\n      ['19 juin 2020', 0, 15, 12, 13],\n      ['20 juin 2020', 1, 15, 12, 13],\n      ['21 juin 2020', 0, 15, 12, 13],\n      ['22 juin 2020', 0, 15, 12, 13]\n    ];\n    this.hotSettings = {\n       data: this.data,\n       colHeaders: true,\n       rowHeaders: true,\n       rowHeights: 24,\n       // rowWidths: 500,\n       // manualColumnResize: true,\n       // manualRowResize: true,\n       selectionMode: 'single',\n       licenseKey: 'non-commercial-and-evaluation'\n     };\n    this.hotTableComponent = React.createRef();\n    \n    // On se connecte au Colyseus server\n    const endpoint = 'ws://localhost:2567';\n    const client = new Colyseus.Client(endpoint);\n    \n    let sendMessage = function(keycode){ console.log('Send message: no room joined yet') };\n    const sendKey = function(e){\n      // on envoie le key code si >= 37 et <= 40 (fleches)\n      if(e.keyCode >= 37 && e.keyCode <= 40){\n        e.stopImmediatePropagation();\n        sendMessage(e.keyCode);\n        \n        // pour laisser un “trail”\n        // this.setCellMeta(this.getSelected()[0][0], this.getSelected()[0][1], 'className', 'c-trail'); \n        // this.render()\n      }\n    };\n    \n    \n    client.joinOrCreate(\"spreadshoot\").then(room => {\n      console.log(\"joined, room id: \" + room.id + \", sess id: \" + room.sessionId );\n      this.setState({'playerId': room.sessionId, 'roomId': room.id});\n      \n      console.log(\"Table size: \", this.data.length, this.data[0].length);\n      \n      sendMessage = function(keycode){\n        room.send({ keycode: keycode });\n      }\n      \n      room.state.entities.onAdd = (entity, sessionId: string) => {\n          // is current player\n          if (sessionId === room.sessionId) {\n            console.log('entity add: this is me!')\n            this.hotTableComponent.current.hotInstance.selectCell(entity.y, entity.x);\n          }else{\n            // enemy: we draw him\n            console.log('entity add: other player')\n            this.hotTableComponent.current.hotInstance.setCellMeta(entity.y, entity.x, 'className', 'c-enemy');\n            this.hotTableComponent.current.hotInstance.render()\n            \n            console.log(entity);\n            this.setState(prevState => ({\n              enemies: [...prevState.enemies,\n                {\n                  x: entity.x,\n                  y: entity.y,\n                  playerId: sessionId,\n                  score: entity.score\n                }\n              ]\n            }));\n          }\n          \n          entity.onChange = (changes) => {\n            if (sessionId === room.sessionId) {\n              // Player moved\n              this.hotTableComponent.current.hotInstance.selectCell(entity.y, entity.x);\n              this.setState({score: entity.score, dead: entity.dead, deaths: entity.deaths});\n              \n              // Mort du joueur\n              if(entity.dead){\n                this.hotTableComponent.current.hotInstance.setDataAtCell(entity.y, entity.x, \"† Perdu †\");\n              }\n            }else{\n              // Enemy moved\n              console.log('Enemy moved')\n              let newEnemies = Object.assign({}, this.state.enemies);\n              \n              for (var i in newEnemies) {\n                if(newEnemies[i]['playerId'] === sessionId){\n                  console.log('before', newEnemies[i])\n                  \n                  // dirty but easy\n                  this.hotTableComponent.current.hotInstance.setCellMeta(newEnemies[i].y, newEnemies[i].x, 'className', '');\n                  this.hotTableComponent.current.hotInstance.render();\n                                    \n                  newEnemies[i].x = entity.x;\n                  newEnemies[i].y = entity.y;\n                  console.log('after', newEnemies[i])\n                  break;\n                }\n              }\n              // this.setState({enemies: newEnemies});\n              \n              // for dirty debug\n              this.hotTableComponent.current.hotInstance.setCellMeta(entity.y, entity.x, 'className', 'c-enemy');\n              this.hotTableComponent.current.hotInstance.render();\n            }\n          }\n      };\n    }).catch(e => {\n      console.error(\"join error\", e);\n      // TODO: message d’erreur pour utilisateur + invitation à refresh (pour 1e version)\n    });\n    \n    // On ecoute les keyboard events\n    Handsontable.hooks.add('beforeKeyDown', sendKey);\n    \n\n  }\n  \n\n  \n  render() {\n    // TODO: le nom de l’enemi / tout remanier\n    /*function EnemyCell({ x = 0, y = 0, name = 'Andrew' }) {\n      let style = {\n        left: 50 * y + (Math.random()*5),\n        top: 24 * x\n      };\n      return (\n        <div className=\"enemyCell\" style={style}>\n        Raoul\n        </div>\n      )\n    }*/\n    \n    let debugBox;\n    if(debug){\n      debugBox = 'Player id: ' + this.state.playerId + ', room id: ' + this.state.roomId + ', enemies: ' + this.state.enemies.length;\n    }else{\n      debugBox = '';\n    }\n    \n    // const EnemyCell = ;\n    \n    return (\n      <div className=\"main\">\n        \n        <h2><img className=\"logo\" src=\"logo-400.png\" alt=\"logo\" /> Vacances 2020</h2>\n        <p>Vous êtes <b>{this.state.name}</b>. Votre score: {this.state.score} points. Vous êtes {this.state.dead ? 'mort' : '(encore) vivant'}.</p>\n        <p>[{debugBox}]</p>\n        <div className=\"tableContainer\">\n          {/*<div className=\"enemyLayer\">\n              {this.state.enemies.length > 0 ? this.state.enemies.map(function(item, index){\n                    return <EnemyCell key={index} x={item.x} y={item.y} enemyId={item.id} />;\n              }): ''}\n          </div>*/}\n          <HotTable ref={this.hotTableComponent} id={this.id} settings={this.hotSettings} tabIndex=\"0\"  />\n        </div>\n      </div>\n    )\n  }\n}\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}